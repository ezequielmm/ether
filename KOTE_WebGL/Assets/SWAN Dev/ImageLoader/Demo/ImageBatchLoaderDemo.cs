// Created by SwanDEV 2018
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ImageBatchLoaderDemo : MonoBehaviour
{
    public bool m_IsDebug = true;
    [Tooltip("Check and keep/delete cached images based on the below settings in the Start method.")]
    public bool m_PerformCacheManagementOnStart;
    [Space]

    [Tooltip("The cache folder path combines by m_CacheDirectoryEnum and m_FolderName at runtime. Images are saved to this folder if the cache feature enabled.")]
    public string m_CacheDirectory = "";
    [Space]
    public FilePathName.AppPath m_CacheDirectoryEnum = FilePathName.AppPath.PersistentDataPath;
    public string m_FolderName = "";

    [Tooltip("The maximum number of files can be stored(Cached) in the cache folder.\n( 0 or smaller means no limit )")]
    [Range(0, 500)] public int m_MaxCacheFilesPerFolder = 100;

    [Tooltip("The minimum time (in seconds) that the files should keep.")]
    public uint m_MinTimeForKeepingFiles;
    [Tooltip("The maximum time (in seconds) that the files can keep.")]
    public uint m_MaxTimeForKeepingFiles;

    public bool m_UseCache = true;
    public bool m_Replace = true;

    [Space()]
    [Tooltip("Set the images to display with UI after all loading finished.")]
    public bool m_WaitForAllImages = false;

    /// <summary>
    /// If 'true', for URL start with 'http', the loader will cache the image as per URL address. This will bypass the filename generating function to use the MD5 hash(generated by the URL) as the filename.
    /// </summary>
    [Header("[ Filename ]")]
    [Tooltip("If 'true', for URL start with 'http', the loader will cache the image as per URL address. This will bypass the filename generating function to use the MD5 hash(generated by the URL) as the filename.")]
    public bool m_CacheAsPerUrl = true;
    public string m_FileNamePrefix = "";

    [Header("[ Queued Loader Setting ]")]
    public bool m_UseQueuedLoader = false;
    public uint m_MaxLoaderNum = 3;

    [Header("[ URL ]")]
    public Text m_Text_ShowUrls;
    public List<string> m_ImageUrls = new List<string>();

    [Header("[ UI ]")]
    public InputField m_InputField_FileNamePrefix;
    public InputField m_InputField_FolderName;
    public InputField m_InputField_Url;
    public Toggle m_Toggle_UseCache;
    public Toggle m_Toggle_Replace;
    public Toggle m_Toggle_CacheAsPerURL;


    [Space()]
    public DImageDisplayHandler m_ImageDisplayHandler;
    [Tooltip("RawImage is better than Image for displaying texture. While Image is suitable for displaying packed sprites.")]
    public RawImage[] m_RawImages;

    private void _UpdateParameters()
    {
        m_FolderName = m_InputField_FolderName.text;
        m_FileNamePrefix = m_InputField_FileNamePrefix.text;
        m_UseCache = m_Toggle_UseCache.isOn;
        m_Replace = m_Toggle_Replace.isOn;
        m_CacheAsPerUrl = m_Toggle_CacheAsPerURL.isOn;
        m_CacheDirectory = FilePathName.Instance.GetAppPath(m_CacheDirectoryEnum);
    }

    public void OnToggleChanged_CacheAsPerURL()
    {
        m_InputField_FileNamePrefix.interactable = !m_Toggle_CacheAsPerURL.isOn;
    }

    public void AddUrl()
    {
        string getUrl = m_InputField_Url.text;

        if(getUrl.StartsWith("http", System.StringComparison.OrdinalIgnoreCase) == false)
        {   // For input text start with 'http' we treat it as local file name. Thus we combine it with the preset AppPath.
            getUrl = System.IO.Path.Combine(System.IO.Path.Combine(FilePathName.Instance.GetAppPath(m_CacheDirectoryEnum), m_InputField_FolderName.text), getUrl);
        }

        if(!string.IsNullOrEmpty(getUrl) && !m_ImageUrls.Contains(getUrl))
        {
            m_ImageUrls.Add(getUrl);
        }

        string showText = "";
        for(int i=0; i<m_ImageUrls.Count; i++)
        {
            showText += m_ImageUrls[i] + "\n";
        }
        m_Text_ShowUrls.text = showText;
    }

    public void ClearUrl()
    {
        m_ImageUrls = new List<string>();
        m_Text_ShowUrls.text = "";
    }

    private void _ClearTextures()
    {
        foreach(RawImage img in m_RawImages)
        {
            if (_imageBatchLoader != null) m_ImageDisplayHandler.Clear(img);

            img.gameObject.SetActive(false);
        }

        Resources.UnloadUnusedAssets(); // Clear un-referenced resources immediately
    }

    public void LoadImagesByUrl()
    {
        StartCoroutine(_LoadImagesByPathOrUrl(m_ImageUrls));
    }

    public void LoadLocalFolderImages()
    {
        _UpdateParameters();

        _ClearTextures();

#if UNITY_ANDROID || UNITY_WEBGL
        if (m_CacheDirectory == Application.streamingAssetsPath)
        {
            Debug.LogWarning("Reminded! Android and WebGL Do Not support getting file paths under directory/folder in StreamingAssetsPath."
                + "\nYou can only load images with the exact path to the files in StreamingAssetsPath on Android. Also, cannot save(cache) files to this directory.");
        }
#endif

        string folderPath = System.IO.Path.Combine(m_CacheDirectory, m_FolderName);
        List<string> imagePaths = FilePathName.Instance.GetFilePaths(folderPath, new List<string>() { ".jpg", ".png" });
        if (imagePaths == null || imagePaths.Count <= 0)
        {
            Debug.LogWarning("No image found in this directory: " + folderPath);
        }
        else
        {
            StartCoroutine(_LoadImagesByPathOrUrl(imagePaths));
        }
    }

    private IMBX.ImageBatchLoader _imageBatchLoader;
    private List<string> _imagePaths;
    private IEnumerator _LoadImagesByPathOrUrl(List<string> imagePaths)
    {
        _imagePaths = imagePaths;

        _UpdateParameters();

        if (imagePaths == null || imagePaths.Count <= 0)
        {
            Debug.LogWarning("Url or file path is empty! Please add complete image link or local path in the ImageUrls list first.");
            yield break;
        }

        _ClearTextures();

        yield return new WaitForEndOfFrame();

        IMBX.ImageLoader.CacheMode cacheMode = m_UseCache ? IMBX.ImageLoader.CacheMode.UseCached : m_Replace ? IMBX.ImageLoader.CacheMode.Replace : IMBX.ImageLoader.CacheMode.NoCache;


        if (_imageBatchLoader == null) _imageBatchLoader = new IMBX.ImageBatchLoader();

        _imageBatchLoader.LMGT.MaxCacheFilePerFolder = (uint)m_MaxCacheFilesPerFolder;

        _imageBatchLoader.LMGT.CacheAsPerUrl = m_CacheAsPerUrl;

        _imageBatchLoader.LMGT.CacheDirectoryEnum = m_CacheDirectoryEnum;

        _imageBatchLoader.LMGT.IsDebug = m_IsDebug;

        _imageBatchLoader.LMGT.SetFileNameFormat(3, 1, " - ");


        //_imageBatchLoader.LMGT.MinTimeForKeepingFiles = 3600 * 24 * 3;    // all files in the target folder should keep 3 days since their lastWriteTime
        _imageBatchLoader.LMGT.MinTimeForKeepingFiles = m_MinTimeForKeepingFiles;

        //_imageBatchLoader.LMGT.MaxTimeForKeepingFiles = 3600 * 24 * 7;    // all files in the target folder can only keep at most 7 days since their lastWriteTime
        _imageBatchLoader.LMGT.MaxTimeForKeepingFiles = m_MaxTimeForKeepingFiles;

        Debug.Log("Cache directory: " + System.IO.Path.Combine(_imageBatchLoader.LMGT.CacheDirectory, m_FolderName));

        if (m_UseQueuedLoader)
            _imageBatchLoader.Load_Queue(m_MaxLoaderNum, imagePaths, m_FileNamePrefix, m_FolderName, cacheMode, _OnComplete, _OnProgress, 0, 30);
        else
            _imageBatchLoader.Load(imagePaths, m_FileNamePrefix, m_FolderName, cacheMode, _OnComplete, _OnProgress, 0, 30);
    }
    
    private void _OnComplete(IMBX.ImageBatchLoader.Results results)
    {
        Debug.Log("All images loaded, number of images: " + results.Count);

        Texture2D texture01 = results.GetTexture(1);

        Debug.Log("Get image by index example, index 1: " + (texture01 != null ? texture01.width + " x " + texture01.height : "null"));

        var resultList = results.GetResultList();
        for (int i = 0; i < resultList.Count; i++)
        {
            Debug.Log("Result-" + resultList[i].m_Index + ": " + resultList[i].m_URL + ", mime type: " + resultList[i].m_DetectedFileMime);
        }

        // Handles all downloaded images at once in this callback.
        if (m_WaitForAllImages)
        {
            List<Texture2D> textureList = results.GetTextureList();
            //if (textureList != null && textureList.Count > 0)
            //{
            //    _ClearTextures();
            //}
            for (int i = 0; i < textureList.Count; i++)
            {
                if (textureList[i] != null)
                {
                    Debug.Log("Index - " + i + " : " + textureList[i].width + " x " + textureList[i].height);

                    if (i < m_RawImages.Length && m_RawImages[i] != null)
                    {
                        m_RawImages[i].gameObject.SetActive(true);
                        m_ImageDisplayHandler.SetRawImage(m_RawImages[i], textureList[i]);
                    }
                }
                else
                {
                    Debug.LogWarning("Fail loading, invalid format or file not exist? Load Path/Url: " + _imagePaths[i] +
                        "\nCache Path: " + System.IO.Path.Combine(System.IO.Path.Combine(_imageBatchLoader.LMGT.CacheDirectory, _imageBatchLoader.LMGT.FolderName), _imageBatchLoader.LMGT.GenerateFileName(i)));
                }
            }
        }
    }

    private void _OnProgress(IMBX.ImageBatchLoader.Result result)
    {
        // Handles the image immediately when any single image is finished download.
        if (m_WaitForAllImages == false)
        {
            Debug.Log("Index: " + result.m_Index + " | Load Image Progress: " + result.m_Progress + " | Mime: " + result.m_DetectedFileMime + " | Extension: " + result.m_DetectedFileExtension);
            uint index = result.m_Index;
            if (index < m_RawImages.Length)
            {
                if (result.m_Texture != null)
                {
                    m_RawImages[index].gameObject.SetActive(true);
                    m_ImageDisplayHandler.SetRawImage(m_RawImages[index], result.m_Texture);
                }
                else
                {
                    Debug.LogWarning("Fail loading, invalid format or file not exist? Load Path/Url: " + _imagePaths[(int)result.m_Index] +
                        "\nCache Path: " + System.IO.Path.Combine(System.IO.Path.Combine(_imageBatchLoader.LMGT.CacheDirectory, _imageBatchLoader.LMGT.FolderName), _imageBatchLoader.LMGT.GenerateFileName(result.m_Index)));
                }
            }
        }
    }


    #region ----- Other Examples -----
    private void Start()
    {
        // Example: (Optional) Perform cache management at the beginning (delete old files that match the specified conditions).
        if (m_PerformCacheManagementOnStart)
        {
            PerformCacheManagement();
        }
    }

    /// <summary> Check to keep/delete cached images in the storage cache folder, based on the cache settings in this script. </summary>
    public void PerformCacheManagement()
    {
        string targetCacheFolderPath = System.IO.Path.Combine(FilePathName.Instance.GetAppPath(m_CacheDirectoryEnum), m_FolderName);
        IMBX.ImageLoader.ManageCachedFiles(targetCacheFolderPath, keepFileNum: (uint)m_MaxCacheFilesPerFolder, minKeepTime: m_MinTimeForKeepingFiles, maxKeepTime: m_MaxTimeForKeepingFiles, fileExtension: ".png", isDebug: true);
    }

    public void ClearStorageCache()
    {
        _imageBatchLoader.ClearStorageCache();
    }


    public void ImageQueuedLoader_Example()
    {
        uint loaderNum = 3;

        IMBX.ImageQueuedLoader qLoader = IMBX.ImageQueuedLoader.Create(loaderNum);

        qLoader.Load(m_ImageUrls, "Image", "MyImages", IMBX.ImageLoader.CacheMode.UseCached,
        (results) => // OnComplete callback
        {
            // Handles all images when all finished...
            Debug.Log("On Complete, all images are loaded: " + results.Count);
        },
        (result) => // OnProgress callback
        {
            // Handles each image when it is loaded...
            Debug.Log("On Progress, current loaded image: " + result.m_Texture.width + " x " + result.m_Texture.height + "  ( Progress:" + (int)(result.m_Progress * 100) + "% )");

            // After handling the texture, you can clear it to release memory (Reminded that you can't access it later, as well as in the OnComplete callback)
            Destroy(result.m_Texture);
        });
    }

    public void ImageBatchLoaderWithQueuedLoad_Example()
    {
        uint loaderNum = 3;

        IMBX.ImageBatchLoader bLoader = new IMBX.ImageBatchLoader();

        bLoader.Load_Queue(loaderNum, m_ImageUrls, "Image", "MyImages", IMBX.ImageLoader.CacheMode.UseCached,
        (results) => // OnComplete callback
        {
            // Handles all images when all finished...
            Debug.Log("On Complete, all images are loaded: " + results.Count);
        },
        (result) => // OnProgress callback
        {
            // Handles each image when it is loaded...
            Debug.Log("On Progress, current loaded image: " + result.m_Texture.width + " x " + result.m_Texture.height + "  ( Progress:" + (int)(result.m_Progress * 100) + "% )");

            // After handling the texture, you can clear it to release memory (Reminded that you can't access it later, as well as in the OnComplete callback)
            Destroy(result.m_Texture);
        });
    }
    #endregion

}
